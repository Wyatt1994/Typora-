- 1. 创建型模式
        单例模式 工厂模式 抽象工厂模式
- 2. 结构型模式
        外观模式    隐藏系统的复杂性，并向客户端提供一个可以调用的接口
        装饰器模式  允许向一个对象增加新的功能，但是却不改变对象的结构(如Java中的IO)
        适配器模式  适配器模式。解决两个系统不兼容的问题(SpringMVC中的HandlerAdapter)
- 3. 行为型模式
        模板模式  定义一个操作中算法的骨架，而将一些步骤延迟到子类中，使得子类不改变算法的结构即可重新定义算法的某个步骤
- 4. J2EE模式
        MVC模式

  5. 模板模式

        不同子类在部分特定函数的实现差异，因此在父类中不进行实现，而在子类中进行实现。例如AQS和和ReentrantLock的Sync实例

  6. 建造者模式

        抽象父类(Builder)+子类+建造指挥者（Director，用于保证流程化的规范，避免画人缺胳膊少腿）

        将一个复杂对象的构建的建造过程细节进行抽象，例如画一个人类。高矮胖瘦都会有区别，于是可以抽象出共同特点,：头，手，脚等等。于是将建造头、手、脚等作为一个抽象父类（PersonBuilder）。不同子类进行继承实现。然后需要一个PersonDirector,传入PersonBuilder的对象引用，在其中将构造头、手、脚的函数封装集成起来。

  7. 观察者模式

        观察者类（Observer)和一个被观察者类。然后将观察者类的实例对象传入被观察者中（可用List存放）。当特定事件发生时，直接取出list中所有观察者，调用其响应动作。类似于回调

  8. 工厂模式

        1）普通工厂模式，即根据特定的参数，实例化返回不同的对象

        2）抽象工厂模式：即根据特定的参数，实例化返回不同的工厂对象

  9. 适配器模式（姚明去美国不会说英语如何交流,因此需要一个适配器，即翻译。例如SpringMVC中的HandlerAdapter?）

        将一个类的接口转换为另外一个接口，使得原本你接口不兼容的类能够一起工作。也就是，当两个对象类做的事情相似，但确实实现的不同接口。因此需要一个适配器将它们整合起来调用。

        1）类适配器模式：**由于java中类不支持多继承，因此在java中是指对象适配器模式**

        2）对象适配器模式：即将需要适配的对象引用传入适配器类，然后调用接口统一方法，其中调用的则是传入对象的特定方法。

![1554039390289](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1554039390289.png)

​	10.单例模式

​	11.职责链模式（例如SpringMVC的拦截器和过滤器，即设定了传入了后继者的调用）

![1554039747870](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1554039747870.png)

​	12.装饰模式：**类似于静态代理**，即添加一些额外的功能。例如各种IO流处理类。传入被装饰者的对象引用，在其中进行方法增强。