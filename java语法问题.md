## JAVA数据类型

1. 基本类型变量，包括字符类型char、数值类型byte、short、int、long、float、double、布尔类型boolean。（void也可以算）
2. 引用类型变量，包括类、接口、数组（基本类型数组和对象数组）。 

### **Java基本类型占用的字节数：**

1字节： byte , boolean
2字节： short , char
4字节： int , float
8字节： long , double
注：1字节(byte)=8位(bits)

调用Integer.SIZE即可获得占用的位数。

引用类型：如果是32位则为4个字节，64位为8个字节。若采用指针压缩，则为4字节。

#### float、double两种类型的最小值 不相同？

实际上Float.MIN_VALUE和Double.MIN_VALUE分别指
的是float和double类型所能表示的最小正数。也就是说存在这样一种情况，0到±Float.MIN_VALUE之间的值
float类型无法表示，0到±Double.MIN_VALUE之间的值double类型无法表示。这并没有什么好奇怪的，因为
这些范围内的数值超出了它们的精度范围。 

### 数值类型转换总结

1. 未带有字符后缀标识的整数默认为int类型；未带有字符后缀标识的浮点数默认为double类型。
2. 如果一个整数的值超出了int类型能够表示的范围，则必须增加后缀“L”（不区分大小写，建议用大
    写，因为小写的L与阿拉伯数字1很容易混淆），表示为long型。
3. 带有“F”（不区分大小写）后缀的整数和浮点数都是float类型的；带有“D”（不区分大小写）后缀
    的整数和浮点数都是double类型的。
4. 编译器会在编译期对byte、short、int、long、float、double、char型变量的值进行检查，如果超出
    了它们的取值范围就会报错。
5. int型值可以赋给所有数值类型的变量；long型值可以赋给long、float、double类型的变量；float型值
    可以赋给float、double类型的变量；double型值只能赋给double类型变量，也就是**精度只能向下转换**（即低精度可以直接赋值给高精度），否则需要**强制类型转换**

### 数值类型运算总结

1. 只要两个操作数中有一个是double类型的，另一个将会被转换成double类型，并且结果也是double类
    型；
2. 否则，只要两个操作数中有一个是float类型的，另一个将会被转换成float类型，并且结果也是float类
    型；
3. 否则，只要两个操作数中有一个是long类型的，另一个将会被转换成long类型，并且结果也是long类
    型； 
4. 否则，两个操作数（包括byte、short、int、char）都将会被转换成int类型，并且结果也是int类型。 

当使用+=、-=、*=、/=、%=、运算符对基本类型进行运算时，遵循如下规则：
• 运算符**右边**的数值将首先被强制转换成与运算符**左边**数值相同的类型，然后再执行运算，且运算结果与
运算符**左边**数值类型相同。 

### 常见问题

##### 不同类型运算问题

```
short s1=1;s1=s1+1;有什么错？short s1=1;s1+=1;有什么错？ 
```

在s1=s1+1;中，s1+1运算的结果是int型，把它赋值给一个short型变量s1，所以会报错；而在s1+=1;中，由于是s1是short类型的，所以1首先被**强制转换**为short型，然后再参与运算，并且结果也是short类型的，因此不会报错 。s1=1+1;为什么不报错呢？这是因为1+1是个**编译时可以确定的常量**，“+”运算在编译时就被执行了，而不是在程序执行的时候，这个语句的效果等同于s1=2，所以不会报错。 



##### 基本类型与包装类“==”问题

当使用“==”运算符在**基本类型**和其**包装类**对象之间比较时，遵循如下规则：

1. 只要两个操作数中有一个是基本类型，就是比较它们的数值是否相等。
2. 否则，就是判断这两个对象的内存地址是否相等，即是否是同一个对象。 

##### Math.round()四舍五入问题

1. 参数的小数点后第一位<5，运算结果为参数整数部分。
2. 参数的小数点后第一位>5，运算结果为参数整数部分绝对值+1，符号（即正负）不变。 
3. 参数的小数点后第一位=5，正数运算结果为整数部分+1，负数运算结果为整数部分 

在源码中，就是调用**(int)floor(a + 0.5f)**; 其将参数值+0.5后交与floor()进行运算，然后取返回值。

那么**floor()**方法的作用又是什么呢？

它是取一个小于等于参数值的最大整数。比如经过floor()方法运算后，如果参数是10.2则返回10，13返回13，-20.82返回-21，-16返回-16等等。 

##### Switch语句支持的数据类型

Switch语句支持byte、char、short、int、**String**（**java7**之后支持，本质上是利用case值得hashcode()得到的hash值进行比较，然后在内部再调用equals()避免哈希冲突。）、**enum**以及**其包装类**，不支持所有**类型对象引用**

##### **ps：**String类**的hashcode()**计算方式

以31为权，每一位为字符的ASCII值进行运算，用自然溢出来等效取模。

主要是因为**31**是一个奇质数，所以31*i=32*i-i=(i<<5)-i，这种位移与减法结合的计算相比一般的运算快很多。

```
1 public int hashCode() {
 2     int h = hash;
 3     if (h == 0 && value.length > 0) {
 4         char val[] = value;
 5 
 6         for (int i = 0; i < value.length; i++) {
 7             h = 31 * h + val[i];
 8         }
 9         hash = h;
10     }
11     return h;
```

##### java Integer.toString和String.valueOf()的区别

**java Integer.toString**

```
public static String toString(int i) {
    if (i == Integer.MIN_VALUE)
        return "-2147483648";
    int size = (i < 0) ? stringSize(-i) + 1 : stringSize(i);
    char[] buf = new char[size];
    getChars(i, size, buf);
    return new String(buf, true);
}


①如果Integer的value值正好是 Integer.MIN_VALUE 直接返回 “-2147483648” 节省时间。 
②得到integer值的十进制的长度，如果负数先求出绝对值的长度，然后再**长度加1**，因为负数的符号位占一位。需要留一位来存放符号为‘-’。 
③得到integer的value值的每一个字符。 
④得到的字符新建字符串返回。 
-------------

static int stringSize(int x) {
        for (int i=0; ; i++)
            if (x <= sizeTable[i])
                return i+1;
                //看看x到底是几位数
    }
//----------------------------------
final static int [] sizeTable = { 9, 99, 999, 9999, 99999, 999999, 9999999,
                                      99999999, 999999999, Integer.MAX_VALUE };
--------------------- 
首先定义了一个数组这个数组中分别存放了一位十进制的最大值，二位十进制的最大值，依次到Integer.MAX_VALUE为止，因为integer的最大值为 Integer.MAX_VALUE，也就是说integer的最大长度为10位。



getChar()方法体
static void getChars(int i, int index, char[] buf) {
        int q, r;
        int charPos = index;
        char sign = 0;

        if (i < 0) {
            sign = '-';
            i = -i;
        }

        // 当i >= 65536的时候每一次获取两位的char值。
        while (i >= 65536) {
            q = i / 100;
        // 等效于: r = i - (q * 100);
            r = i - ((q << 6) + (q << 5) + (q << 2));
            //使用移位操作快速计算出q*100，2^6+2^5+2^2=64+32+4=100.
            i = q;
            //假设输入为65536，计算后r=65536-655*100=36
            //DigitOnes[36]=6,DigitTens[r]=3
            
            buf [--charPos] = DigitOnes[r];
            buf [--charPos] = DigitTens[r];
        }

        // 当 i <= 65536的时候每次只获取一位的char值
        // assert(i <= 65536, i);
        for (;;) {
            q = (i * 52429) >>> (16+3);
            //q/10,2^19=524288, (double)52429/(1<<19)=0.10000038146972656
            r = i - ((q << 3) + (q << 1));  // r = i-(q*10) ...
            buf [--charPos] = digits [r];
            i = q;
            if (i == 0) break;
        }
        if (sign != 0) {
            buf [--charPos] = sign;
            //如果是负数加上符号位
        }
    }
//--------------------------------------
final static char [] DigitOnes = {
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        } ;

//--------------------------------------
final static char [] DigitTens = {
        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',
        '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
        '2', '2', '2', '2', '2', '2', '2', '2', '2', '2',
        '3', '3', '3', '3', '3', '3', '3', '3', '3', '3',
        '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',
        '5', '5', '5', '5', '5', '5', '5', '5', '5', '5',
        '6', '6', '6', '6', '6', '6', '6', '6', '6', '6',
        '7', '7', '7', '7', '7', '7', '7', '7', '7', '7',
        '8', '8', '8', '8', '8', '8', '8', '8', '8', '8',
        '9', '9', '9', '9', '9', '9', '9', '9', '9', '9',
        } ;
--------------------- 


总结：
①在 i >= 65536 的时候每次能够求出2位的char 值，求2位的char值时利用了两个数组 DigitOnes 和 DigitTens 就是在这两个数组的帮助下才能一次求出2位的char值下面就简单的说一下怎样利用这两个数组来分别求出个位和十位上的值的，假如现在得到两位数是 65，个位上是 5 要得到个位上的5，这时候不管十位是多少个位上一定是5，所以数组DigitOnes的 05，15，25，35，45，55，65，75，85，95位置上都是 5，这样不管是25，还是35 都能得到个位上的5。在来看看如何得到十位上的数，还是65，十位是6，所以DigitTens 的60，61，62，63，64，……69 位置上都是6。

② q = (i * 52429) >>> (16+3);这段代码其实就是q=i/10 ,其中 (double)52429/(1<<19)=0.10000038146972656也就是在int型的时候计算一个数的十分之1的精度是够的，可以看出jdk开发者的这种优化意识是非常强的。 
③(q << 6) + (q << 5) + (q << 2) 这段等价于q*100，因为 q*2^6+q*2^5+q*2^2=q*(64+32+4)=100q.这里为什么不直接使用q*100，而要使用位移操作，因为其实q*100底层还是要进行位移操作的，直接使用位移操作效率更高，这也给我们编程带来启示。能够优化的时候一定要优化。
--------------------- 

```

**String.valueOf()**

```
public static String valueOf(int i) {
    return Integer.toString(i);
}


这里调用了Integer.toString()的方法，可以看出String的valueof方法是将各种类型转换成String，内部重载了不同类型转String的处理，所以推荐使用valueof方法。
```



##### char类型存放中文

为什么一个中文汉字可以保存在一个char变量里呢？

因为在JAVA中，一个char是**2**个字节（byte），而一个中文汉字如果是作为一个字符（char c='我'），根据默认编码（java的编码为Unicode，和GBK一致）是2个字节。而英文字母都是一个字节的，因此它也能保存到一个byte里，一个中文汉字却不能。 

char类型输出为字符本身，byte类型则为整数（即表示比short更小的整数）。char类型输出不能直接“+”连接，否则输出为整数。char类型也可以直接和byte进行加减操作。

```
char c='c';
byte d='d';
char e='e';
int f=c+d;
System.out.println(c);
System.out.println(d);
System.out.println(c+e);
System.out.println(f);

输出：c
	 100
	 200
	 199
```

##### String字符串反转方法

1.利用str.charAt(str.length()-1)反向打印输出

2.利用str.toCharArray()转换为char[]数组，再反向打印输出

3.利用StringBuffer.reverse().toString()方法

##### String和数组

String的长度实际上就是它的属性--char型数组value的长度，（因此需要一个方法返回其属性的长度，便于记忆）。数组是**没有**length()方法的，大家知道，在JAVA中，数组也被作为对象来处理，它的方法都继承自Object类。数组有一个属性length，这也是它唯一的属性，对于所有类型的数组都是这样。 



## 子类向上转型属性覆盖问题

当定义一个Parent parent=new Son()时，通过向上转型将一个子类对象赋给了一个父类引用。其中，调用parent.xxx()方法时，若子类重写了该方法，则会被覆盖，即调用子类的方法，在方法中涉及的变量，即使是和父类同名变量也是调用的子类的变量值。相当于给子类和父类的同名变量都分别进行了初始化。当调用parent.a变量时，调用的都是父类的a的值。也就是说，**方法才存在覆盖，而同名属性变量不存在覆盖的情况**。**除了同名方法会调用子类的方法外，其他情况都当做一个父类来看待。**

**总结**：首先需要说明的是，即使子类声明了与父类完全一样的成员变量，也不会覆盖掉父类的成员变量。而是在子类实例化时，会同时定义实例化了**两个成员变量**，子类也可以同时访问到这两个成员变量(this.i&super.i)，但父类不能访问到子类的成员变量（父类不知道子类的存在）。

而具体在方法中使用成员变量时，究竟使用的是父类还是子类的成员变量，则由方法所在的类决定；即，方法在父类中定义和执行，则访问的是父类的成员变量，方法在子类中定义（包括覆盖父类方法）和执行，则访问的是子类的成员变量。

## final、finally、finalize

**final**修饰的方法不可被子类继承重写，但并不影响子类定义一个同名方法；final修饰的类不可被继承，但该类中的非final修饰的变量依然可以改变；final修饰的变量不可被更改，其中JVM在进行类初始化时设定的默认值不算一次赋值。

**finally**语句块是在程序退出方法之前被执行的。同样，finally语句块是在循环被跳过（continue）和中断（break）之前被执行的。 

**finalize**是一个Object类中的方法，用于对象被回收时执行的操作。

## Object类的方法

toString(),clone()(分为浅拷贝和深拷贝，浅拷贝表示没有对该对象的包含的引用指向对象进行拷贝，只拷贝了的引用)，wait(),notify(),notifyAll(),hashcode(),getClass(),equals(),finalize()

## 值传递和引用传递

当**基本类型**的变量被当作参数传递给方法时，JAVA虚拟机所做的工作是把这个值拷贝了一份，然后把拷贝后的
值传递到了方法的内部。

当**引用型变量**被当作参数传递给方法时JAVA虚拟机它会拷贝一份这个变量所持有的引用，然后把它传递给JAVA虚拟机为方法创建的局部变量，从而这两个变量指向了同一个对象。因此，以下代码pt和传入的对象引用指向相同的内存空间地址，因此pt.num会找到对应的栈中的原对象的num并进行修改。

`public void add(ParamTest pt) {
​	pt.num += 20;
  } `  

**结论**：

1. 基本类型和基本类型变量被当作参数传递给方法时，是值传递。在方法实体中，无法给原变量重新赋
   值，也无法改变它的值。

     	    2. 对象和引用型变量被当作参数传递给方法时，在方法实体中，无法给原变量重新赋值，但是可以改变它
             所指向对象的属性。至于到底它是值传递还是引用传递，这并不重要，重要的是我们要清楚当一个引用
             被作为参数传递给一个方法时，在这个方法体内会发生什么。 





## 编码问题

### 判断是否为中文字符

Unicode/GBK： 中文2字节
UTF-8： 中文通常3字节，在拓展B区之后的是4字节
综上，中文字符在编码中占用的字节数一般是2-4个字节。

UTF中文占三个字节，字符占一个字节，GBK中文占两个字节。若通过字符串赋值一个中文，String s="我",则输出

```
System.out.println(s.getBytes("UTF-8").length);
```

输出长度为3，若设定为GBK，则为2。该方法可用于判断字符串中**某个字符是否为中文**。

### 判断char占几个字节

判断char占几个字节，也就是将char转换为byte类型。因此直接新建一个byte[2]数组接受即可。

```
public static byte[] charToByte(char c) { 
        byte[] b = new byte[2]; 
        b[0] = (byte) ((c & 0xFF00) >> 8); 
        b[1] = (byte) (c & 0xFF); 
        return b; 
}
```

## 回调、静态代理、动态代理

所谓**回调**：就是A类中调用B类中的某个方法C，然后B类中反过来调用A类中的方法D，D这个方法就叫回调方法，跟静态代理最重要的区别就是接收B类引用的A类需要实现CallBack回调接口，调用C方法比静态代理方式多了一个参数Callback callback，即A类自身的引用（因为A类实现了该接口，可作为该类型传入），然后再在C方法中通过引用调用了A类的另外方法D。例如**过滤器**就是基于该原理。

**静态代理**：就是传入一个其他引用，然后在代理类中调用该引用的方法，要求被代理和代理类都实现了**同一个接口**。（Thread和传入的runnabe刚好都实现了Runnabe接口）

**动态代理**：代理类是实现了一个InvocationHandler的接口，我们通过reflect.Proxy的类的newProxyInstance方法就可以得到这个接口的实例，然后再来作为参数传递进去，这里每一个在代理类上处理的东西也会被重定向到调用处理器上。其中，被代理类必须实现某个接口，而代理类不需要实现同一个接口，而是直接传入被代理对象的引用。

至于动态代理和静态代理的**区别**，即动态代理是动态的创建代理和动态的处理方法的，这也是反射的一个重要体现之处。

```
核心代码：
RealObject real = new RealObject();
ProxyInterface proxy = (ProxyInterface)Proxy.newProxyInstance(ProxyInterface.class.getClassLoader(),new Class[]{ProxyInterface.class}, new ProxyObject(real));
proxy.say();
}
}
interface ProxyInterface{
void say();
}
//被代理类
class RealObject implements ProxyInterface{
public void say(){
System.out.println("i'm talking");
}
}
//代理类，实现InvocationHandler 接口
class ProxyObject implements InvocationHandler{
private Object proxied = null;
public ProxyObject(){
}
public ProxyObject(Object proxied){
this.proxied  = proxied;
}
public Object invoke(Object arg0, Method arg1, Object[] arg2) throws Throwable {
System.out.println("hello");
return arg1.invoke(proxied, arg2);
};
}
```



## 日期时间问题

```
Date d=new Date()         ------------------->Tue Jul 22 10:44:47 CST 2008`

Date d=new Date(Long类型的整数)---------------------------->根据传入的毫秒数创建日期

d.getTime()                                   ---------------------------------->获取相对于1970...的毫秒数。

d.setTime()                                   ------------------------------------>设置相对其的毫秒数 

d.after(d1)/before(d1)                 ------------------------------------>日期比较，返回boolean

d.compareTo(d1)                        ------------------------------------->日期比较，返回-1,0,1表示不同的先后关系。
```

Date类直接操作年月日时分秒的方法都被废弃而被**Calendar**代替，new GregorianCalendar().getTime()即可转换为Date对象，而new GregorianCalendar().setTime(new Date())，即可转换为Calendar对象。

日期创建方式：

```
Calendar c1 = Calendar.getInstance(); 

Calendar c2 = new GregorianCalendar(); 

Calendar c3 = new GregorianCalendar(2008, 8, 8); 

DateFormat df = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
String AM_PM=df.format(传入c1/c2/c3.getTime); 
(Am_PM=0表示为AM，即上午)


将日期对象转换为字符串

// 创建一个日期格式表达式
String pattern = "年代:G;年份:y;月份:M;日:d;时(1~12):h;时(0~23):H;分:m;秒:s;毫秒:S;星
// 使用日期格式表达式创建一个SimpleDateFormat对象
SimpleDateFormat df = new SimpleDateFormat(pattern);
System.out.println(df.format(new Date()));

将字符串转换为日期对象
String s = "2008-08-08";
String pattern = "yyyy-MM-dd";
SimpleDateFormat df = new SimpleDateFormat(pattern);

Date date = df.parse(s);
```

注：

1. 在创建GregorianCalendar对象时，月份值都设定为8，但打印结果都是9月份。这并不是我们的代码有
     问题，而是因为JAVA表示的月份是**从0开始**的，也就是说它用来表示月份的数值总是比实际月份值小
       1。因此我们要表示8月份，就是应该设置8-1=7这个值。也可使用Calendar.JANUARY = 0 这个常量表示一月传入。
2. GregorianCalendar的小时数是**24小时制**的。 



## 抽象类和接口的区别

就把抽象类当做普通的类来看待，但不能直接new实例化，只能在子类实例化时会先调用父类的构造方法。



1.普通成员变量：抽象类中可以有普通成员变量，而接口中不能有普通成员变量。

2.静态成员变量：抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static类型，并且默认为public static final类型。

3.普通方法（非抽象）：抽象类中可以包含非抽象的普通方法，而接口中所有的方法必须是抽象的，不能有非抽象的普通方法。

4.构造方法：抽象类里可以有构造方法，而接口内不能有构造方法。

5.静态方法：抽象类中可以包含静态方法，接口内不能包含静态方法。

6.访问修饰符：抽象类中的抽象方法的访问类型可以是public ，protected和private，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。

7.继承问题：一个类可以实现多个接口，但只能继承一个抽象类，但可以实现多个接口，且接口可以继承多个接口。



**抽象类可以不含抽象方法。**

**抽象类继承抽象类，或者实现接口时，可以部分、全部或者完全不实现父类抽象类的抽象（abstract）**
**方法，或者父类接口中定义的接口。** 

一个普通类实现一个接口后，必须实现这个接口中定义的所有方法，否则就只能被定义为**抽象类**。 

一个普通类继承抽象类，或者实现接口时，必须全部实现父类抽象类的全部抽象（abstract）方法，或者父类接
口中定义的全部接口 



## 多态：

重写、重载、向上转型

### 重写与重载

• **重写**，英文名是overriding，是指在继承情况下，子类中定义了与其基类中方法具有相同**型构**的新方
法，就叫做子类把基类的方法重写了。这是实现**多态**必须的步骤。
• **重载**，英文名是overloading，是指在同一个类中定义了一个以上具有相同名称，但是**型构**不同的方
法。在同一个类中，是不允许定义多于一个的具有相同型构的方法的 

构造器可以**重载**，但不能被**重写**。因为子类无法定义与基类具有相同型构的构造器 。当子类有多个重载的构造方法时，都会**先隐式先调用父类的空构造器**。

## 线程与进程

线程和进程是不同的，每个进程都是一个独立运行的程序，拥有自己的变量，且**不同进程间的变量不能共享**；而线程是运行在进程内部的，每个正在运行的进程至少有一个线程，而且不同的线程之间可以**在进程范围**内共享数据。也就是说**进程有自己独立的存储空间**，而线程是和它所属的进程内的其他线程共享一个存储空间。线程的使用可以使我们能够并行地处理一些事情。 

### 线程的两种实现方式区别

继承Thread类的方式实现起来较为简单，但是继承它的类就**不能再继承别的类**了，因此也就不能继承别的类的有用的方法了，**不适合资源共享**。而使用是想Runnable接口的方式就不存在这个问题了，而且这种实现方式将线程主体和线程对象本身分离开来，逻辑上也较为清晰 

### 线程执行入口

一种是实现Runable接口，一个是继承Thread类重写run()方法。在Thread源码中，本身已经实现了run()方法。也就是说，如果是继承Thread类，则会覆盖原有的run()方法，执行新的run方法。若传入Runable接口，则会先执行线程自带的run()方法，相当于通过**静态代理**的方式调用Runable的run方法。

```
public void run() {
    if (target != null) {
        target.run();
    }
}
```

### 线程的状态

线程总共有5大状态，通过上面第二个知识点的介绍，理解起来就简单了。

![è¿éåå¾çæè¿°](http://www.blogjava.net/images/blogjava_net/santicom/360%E6%88%AA%E5%9B%BE20110901211600850.jpg)



**新建状态：**新建线程对象，并没有调用start()方法之前

**就绪状态：**调用start()方法之后线程就进入就绪状态，但是并不是说只要调用start()方法线程就马上变为当前线程，在变为当前线程之前都是为就绪状态。值得一提的是，线程在睡眠和挂起中恢复的时候也会进入就绪状态哦。

**运行状态：**线程被设置为当前线程，开始执行run()方法。就是线程进入运行状态

**阻塞状态：**线程被暂停，比如说调用sleep()方法后线程就进入阻塞状态

**死亡状态：**线程执行结束



线程的状态被扩充为新建、可运行、**运行**、阻塞、等待、定时等待、死亡其中。

1. **NEW（新建状态、初始化状态）**：线程对象已经被创建，但是还没有被启动时的状态。这段时间就是
     在我们调用new命令之后，调用start()方法之前。因为线程的运行需要一些条件（比如内存资源，**程序计数器、Java栈、本地方法栈**都是线程私有的，所以需要为线程分配一定的内存空间），只有线程运行需要的所有条件满足了，才进入就绪状态。
2. **RUNNABLE（可运行状态、就绪状态）**：在我们调用了线程的start()方法之后线程所处的状态。处于
     RUNNABLE状态的线程在JAVA虚拟机（JVM）上是运行着的，但是它可能还正在等待操作系统分配给
       它相应的运行资源以得以运行。
3. **BLOCKED（阻塞状态、被中断运行）**：一个线程因为等待临界区的锁被阻塞产生的状态 **Lock** 或者**synchronize** 关键字产生的状态。
4. **WAITING（等待状态）**：一个线程进入了锁，但是需要等待其他线程执行某些操作。时间不确定 
     当wait，join，park方法调用时，进入**waiting**状态。前提是这个线程已经**拥有锁**了。
5. **TIMED_WAITING（定时等待状态）**：一个线程进入了锁，但是需要等待其他线程执行某些操作。时间确定 
     通过sleep或wait timeout方法进入的限期等待的状态。
6. **TERMINATED（死亡状态、终止状态）**：线程完成执行后的状态。线程执行完run()方法中的全部代
     码，从该方法中退出，进入TERMINATED状态。还有一种情况是run()在运行过程中抛出了一个异常，
       而这个异常没有被程序捕获，导致这个线程异常终止进入TERMINATED状态。 
7. **执行态（Running）**:执行run()方法。

### **Sleep()和wait()的区别**

**sleep()方法**并不会让线程释放它所持有的**同步锁**，而且在这期间它也不会阻碍其它线程的运行，需要捕获InterruptedException类型的异常 。 这是因为线程在sleep()期间，有可能被持有它的引用的其它线程调用它的interrupt()方法而中断。 

**wait()方法**会释放他所持有的同步锁和所有**同步资源** 。wait()方法同样会被Thread类的interrupt()方法中断，并产生一个InterruptedException异常 



## HashTable为什么不允许插入空值

因为hashtable,concurrenthashmap它们是用于多线程的，并发的 ，如果map.get(key)得到了null，不能判断到底是映射的value是null,还是因为没有找到对应的key而为空，而用于单线程状态的hashmap却可以用contains（key） 去判断到底是否包含了这个null。  



